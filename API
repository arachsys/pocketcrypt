duplex.h
========

The Gimli and Xoodoo permutations operate over a state of twelve 32-bit
words, manipulated here as an array of three 128-bit uint32x4_t vectors.
Bytes are absorbed and squeezed in 16-byte chunks, treated as little-endian
words to ensure duplex operations are independent of platform byte order.

Each duplex call accepts, updates and returns a size_t byte counter as well
as the duplex_t state. This allows partial chunks to be seamlessly absorbed,
squeezed, encrypted and decrypted in a streaming setting. The counter should
be initialised as zero at the same time as the state, then passed to and
received from each duplex operation.

Define duplex_permute as duplex_gimli or duplex_xoodoo before including
duplex.h to explictly select the permutation. The default is duplex_gimli.

duplex_rate is defined as constant size_t 16, the size in bytes of the rate
portion of the duplex state, useful to avoid magic numbers in client code.


Initialising a duplex state
---------------------------

To declare a duplex state initialised to zero, use

  duplex_t state = { 0 };
  uint8_t counter = 0;

To reset an existing duplex state, use

  memset(state, 0, sizeof(duplex_t));
  counter = 0;

and a duplex_t array can safely be cloned with

  memcpy(new, old, sizeof(duplex_t));


Permuting a duplex state
------------------------

To directly permute a duplex state, use

  duplex_permute(state);

Typically this is bundled into the higher-level duplex operations below.


Absorbing a data buffer
-----------------------

To absorb an arbitrary-length buffer of bytes into a duplex state, call

  counter = duplex_absorb(state, counter, data, length);

Each chunk of 16 bytes is absorbed in turn, then the state is permuted
before continuing. After any final partial chunk is absorbed, the updated
counter is returned ready for the next duplex_absorb() or duplex_pad() call.


Squeezing data into a buffer
----------------------------

To squeeze data from a duplex state into a buffer, call

  counter = duplex_squeeze(state, counter, data, length);

This extracts bytes from the duplex state into the buffer, permuting the
state after each 16-byte chunk. After any final partial chunk is squeezed,
the updated counter is returned.


Encrypting a data buffer
------------------------

To encrypt an arbitrary-length buffer of bytes based on the current duplex
state, for example after absorbing a shared key and nonce, call

  counter = duplex_encrypt(state, counter, data, length);

Each chunk of 16 bytes is absorbed in turn, the result replacing that chunk
as ciphertext before permuting and continuing to the next chunk. After any
final partial chunk is encrypted, the updated counter is returned ready for
the next duplex_encrypt() or duplex_pad() call.

Remember that authentication requires a tag to be squeezed and appended
after encrypting the padded message, so it can be checked by the receiver.


Decrypting a data buffer
------------------------

To decrypt an arbitrary-length buffer of bytes based on the current duplex
state, for example after absorbing a shared key and nonce, call

  counter = duplex_decrypt(state, counter, data, length);

The rate portion of the duplex state is mixed into each chunk of 16 bytes,
then the resulting decrypted plaintext is absorbed back into the state
before permuting and continuing to the next chunk. After any final partial
chunk is decrypted, the updated counter is returned ready for the next
duplex_decrypt() or duplex_pad() call.

Remember that authentication requires the received tag to be checked against
one squeezed from the duplex state after decrypting the message.


Padding the state
-----------------

To prevent extension attacks following an operation on variable-length data,
pad the state by calling

  counter = duplex_pad(state, counter);

after the final duplex_absorb(), duplex_encrypt() or duplex_decrypt(). The
counter will advance to the next multiple of 16 bytes.


Ratcheting the state
--------------------

To ensure forward secrecy during a session, call

  counter = duplex_ratchet(state, counter);

This irreversibly ratchets the duplex state by zeroing the rate portion of
the state and permuting, thus preventing rollback even from a completely
compromised state. The counter will advance by exactly 16 bytes.


Constant-time comparison
------------------------

To compare two equal-sized byte arrays in constant time, call

  duplex_compare(a, b, length);

This returns 0 for equality, -1 otherwise. If a or b is null, the other
argument is compared with zero.

This is useful for validating authentication tags or checking other secret
data without inadvertently revealing the location of the first discrepancy
through the time taken to detect it.


x25519.h
========

Both scalars and curve points are represented by 32-byte arrays. The
correct-sized array type and standard base point as exported by x25519.h as

  typedef uint8_t x25519_t[32];
  const x25519_t x25519_generator = { 9 };


Scalar multiplication
---------------------

To multiply a curve point by a scalar, call

  x25519(out, scalar, point);

If out is all-zero, -1 is returned to flag the non-contributory behaviour.
Otherwise, x25519() returns 0. README discusses the significance of this.

Generate a key pair by multiplying x25519_generator (point) by a random
scalar. Calculate a shared secret by multipling the secret key (scalar) by
the public key (point).


Mapping field elements to curve points
--------------------------------------

For any field element, call

  x25519_point(out, element);

to map it onto a curve point using the Elligator 2 mapping with non-square
parameter u = 2. Multiply by eight to eliminate the cofactor if needed.


Signatures
----------

Given an identity secret, ephemeral secret and challenge, generate a
response with

  x25519_sign(response, challenge, ephemeral, identity);

Given an identity public key, ephemeral public key, challenge and response,
verify the response with

  x25519_verify(response, challenge, ephemeral, identity);

which returns 0 for a valid signature, -1 otherwise.

See the detailed discussion in README for further information.
